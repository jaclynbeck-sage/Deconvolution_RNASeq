library(synapser)
library(Seurat)
library(reshape2)
library(stringr)
library(GEOquery)
library(reticulate)
library(HDF5Array)
library(dplyr)
library(readxl)
library(SingleCellExperiment)

source("Filenames.R")

##### Generic functions #####

# Assumes you have already authenticated a Synapse login or have a Synapse
# config set up with proper credentials
DownloadFromSynapse <- function(synIDs, downloadLocation) {
  synLogin()

  files <- list()

  for (name in names(synIDs)) {
    files[[name]] <- synGet(synIDs[[name]]$id, version = synIDs[[name]]$version,
                            downloadLocation = downloadLocation)
  }

  return(files)
}

# Standardize cell type names across all data sets.
# Broad cell types only for now, we'll deal with fine cell types later...
RemapCelltypeNames <- function(celltypes) {
  # Reduces the number of possible variations
  celltypes_mod <- str_to_lower(str_sub(celltypes, end = 2))

  remap <- melt(list(Astrocyte = c("as"),
                     Endothelial = c("en"),
                     Excitatory = c("ex", "gl"), # gl = Glut
                     Inhibitory = c("in", "ga"), # ga = GABA
                     Microglia = c("mg", "mi"),
                     Oligodendrocyte = c("od", "ol"),
                     OPC = c("op"),
                     Pericyte = c("pe"),
                     VLMC = c("vl")))
  rownames(remap) <- remap$value

  return(remap[celltypes_mod, "L1"])
}

# This function is unused, saving just in case.
# gene.list is a vector of gene symbols
# TODO: Seurat has a GeneSymbolThesaurus function to get aliases. Might be useful
GeneSymbolToEnsembl_Biomart <- function(gene.list) {
  mart <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")
  ens.genes <- getBM(attributes = c("external_gene_name", "ensembl_gene_id"),
                     filters = "external_gene_name",
                     values = gene.list,
                     mart = mart)

  dupes <- duplicated(ens.genes$external_gene_name)
  ens.genes <- ens.genes[!dupes,]

  genes <- data.frame(Symbol = gene.list)
  genes <- merge(genes, ens.genes,
                 by.x = "Symbol", by.y = "external_gene_name", all = TRUE)
  colnames(genes) <- c("Symbol", "Ensembl.ID")
  rownames(genes) <- genes$Symbol

  return(genes)
}


# Use the gene conversion list from Step01 to get the mapping between Ensembl ID
# and gene symbol
EnsemblIdToGeneSymbol <- function(gene_list) {
  gene_conversions <- read.csv(file_gene_list)

  rownames(gene_conversions) <- gene_conversions$ensembl_gene_id
  overlap <- intersect(gene_list, gene_conversions$ensembl_gene_id)

  gene_conversions <- gene_conversions[overlap,]

  genes <- gene_conversions %>%
              select(ensembl_gene_id, canonical_symbol, exon_length) %>%
              dplyr::rename(hgnc_symbol = canonical_symbol) %>%
              arrange(ensembl_gene_id)
  return(genes)
}

# We have single cell data sets that were aligned to different versions of
# GRCh 38 and have different symbols for the same genes. This function maps
# old symbols to new ones based on the gene list generated by Step01
UpdateGeneSymbols <- function(dataset, gene_list) {
  version <- switch(dataset,
                    "cain" = "symbol_v98",
                    "lau" = "symbol_v93",
                    "leng" = "symbol_v84",
                    "mathys" = "symbol_Mathys", # They provided their mapping as a file
                    "morabito" = "symbol_v94",
                    "seaRef" = "symbol_v98",
                    "seaAD" = "symbol_v98") # TODO I haven't checked the larger SEA-AD set

  gene_conversions <- read.csv(file_gene_list)
  gene_conversions$original_symbol <- gene_conversions[,version]

  genes <- subset(gene_conversions, original_symbol %in% gene_list)
  rownames(genes) <- make.unique(genes$original_symbol, sep = "/")

  genes <- genes[rownames(genes) %in% gene_list,] %>%
              dplyr::select(ensembl_gene_id, canonical_symbol, original_symbol) %>%
              dplyr::rename(hgnc_symbol = canonical_symbol) %>%
              arrange(ensembl_gene_id)

  return(genes)
}


##### Generic functions that call dataset-specific functions #####

DownloadData <- function(dataset, metadata_only = FALSE) {
  files <- switch(dataset,
                  "cain" = DownloadData_Cain(metadata_only),
                  "lau" = DownloadData_Lau(metadata_only),
                  "leng" = DownloadData_Leng(metadata_only),
                  "mathys" = DownloadData_Mathys(metadata_only),
                  "morabito" = DownloadData_Morabito(metadata_only),
                  "seaRef" = DownloadData_SEARef(metadata_only),
                  "seaAD" = DownloadData_SEAAD(metadata_only),
                  "Mayo" = DownloadData_Mayo(metadata_only),
                  "MSBB" = DownloadData_MSBB(metadata_only),
                  "ROSMAP" = DownloadData_ROSMAP(metadata_only))

  return(files)
}

ReadMetadata <- function(dataset, files) {
  metadata <- switch(dataset,
                     "cain" = ReadMetadata_Cain(files),
                     "lau" = ReadMetadata_Lau(files),
                     "leng" = ReadMetadata_Leng(files),
                     "mathys" = ReadMetadata_Mathys(files),
                     "morabito" = ReadMetadata_Morabito(files),
                     "seaRef" = ReadMetadata_SEARef(files),
                     "seaAD" = ReadMetadata_SEAAD(files),
                     "Mayo" = ReadMetadata_BulkData(files),
                     "MSBB" = ReadMetadata_BulkData(files),
                     "ROSMAP" = ReadMetadata_BulkData(files))
  return(metadata)
}

ReadCovariates <- function(dataset, files) {
  covariates <- switch(dataset,
                       "cain" = ReadMetadata_Cain(files)$covariates,
                       "lau" = ReadCovariates_Lau(files),
                       "leng" = ReadMetadata_Leng(files)$covariates,
                       "mathys" = ReadMetadata_Mathys(files)$covariates,
                       "morabito" = ReadMetadata_Morabito(files),
                       "seaRef" = ReadMetadata_SEARef(files)$covariates,
                       "seaAD" = ReadMetadata_SEAAD(files)$covariates,
                       "Mayo" = ReadMetadata_BulkData(files)$covariates,
                       "MSBB" = ReadMetadata_BulkData(files)$covariates,
                       "ROSMAP" = ReadMetadata_BulkData(files)$covariates)
  return(covariates)
}

ReadCounts <- function(dataset, files, metadata) {
  counts <- switch(dataset,
                   "cain" = ReadCounts_Cain(files, metadata),
                   "lau" = ReadCounts_Lau(files, metadata),
                   "leng" = ReadCounts_Leng(files),
                   "mathys" = ReadCounts_Mathys(files),
                   "morabito" = ReadCounts_Morabito(files),
                   "seaRef" = ReadCounts_SEARef(files),
                   "seaAD" = ReadCounts_SEAAD(files),
                   "Mayo" = ReadCounts_BulkData(files),
                   "MSBB" = ReadCounts_BulkData(files),
                   "ROSMAP" = ReadCounts_BulkData(files))
  return(counts)
}


##### Custom functions for each data set #####


##### Cain, et al., 2020 [preprint] #####
# https://doi.org/10.1101/2020.12.22.424084

DownloadData_Cain <- function(metadata_only = FALSE) {
  synIDs <- list("metadata" = list(id = "syn23554294", version = 5),
                 "biospecimen_metadata" = list(id = "syn21323366", version = 17),
                 "clinical_metadata" = list(id = "syn3191087", version = 11),
                 "counts" = list(id = "syn23554292", version = 3),
                 "genes" = list(id = "syn23554293", version = 2))

  if (metadata_only) {
    synIDs <- synIDs[1:3]
  }

  files <- DownloadFromSynapse(synIDs, dir_cain_raw)
  return(files)
}

ReadMetadata_Cain <- function(files) {
  metadata <- read.csv(files$metadata$path)

  # Diagnosis is in the specimen ID for each donor
  dx_defs <- c("Cdx1-pAD0" = "Control",
               "Cog1-Path0" = "Control",
               "Cdx1-pAD1" = "Control w/ Pathology",
               "Cog1-Path1" = "Control w/ Pathology",
               "Cdx4-pAD0" = "Non-AD Dementia",
               "Cog4-Path0" = "Non-AD Dementia",
               "Cdx4-pAD1" = "AD",
               "Cog4-Path1" = "AD")

  tmp <- as.data.frame(str_split(metadata$specimenID, "-", simplify = TRUE))
  tmp <- paste(tmp$V4, tmp$V5, sep = "-")

  metadata$diagnosis <- dx_defs[tmp]

  metadata$Cell.Type <- RemapCelltypeNames(metadata$Cell.Type)

  # Fix the 'no.clus' label for sub.cluster
  no_clust <- metadata$sub.cluster == "no.clus"
  metadata$sub.cluster[no_clust] <- metadata$Cell.Type[no_clust]

  # Assign oligodendrocyte subtypes based on the oligodendrocyte 'topic weights'
  # in the metadata. The paper notes that oligo subtypes are more of a spectrum
  # than discrete subtypes, however for our purposes we partition into discrete
  # subtypes by using the highest-weighted 'topic'.
  cols <- paste0("oligodendrocytes.topicweight.", 1:4)
  oligos <- which(metadata$Cell.Type == "Oligodendrocyte")
  olig_types <- apply(metadata[oligos,cols], 1, which.max)
  metadata$sub.cluster[oligos] <- paste0("Oligo.", olig_types)

  metadata <- metadata[, c("cell_name", "specimenID", "diagnosis",
                           "Cell.Type", "sub.cluster" )]

  biospecimen <- read.csv(files$biospecimen_metadata$path)
  biospecimen <- subset(biospecimen, specimenID %in% metadata$specimenID) %>%
                    select(individualID, specimenID)

  clinical <- read.csv(files$clinical_metadata$path)
  clinical <- subset(clinical, individualID %in% biospecimen$individualID)
  clinical <- merge(clinical, biospecimen, by = "individualID") %>%
                  dplyr::rename(sample = specimenID)

  # Fix age fields to be numeric
  clinical$age_death[clinical$age_death == "90+"] <- 90
  clinical$age_death <- as.numeric(clinical$age_death)
  clinical$age_at_visit_max[clinical$age_at_visit_max == "90+"] <- 90
  clinical$age_at_visit_max <- as.numeric(clinical$age_at_visit_max)

  return(list("metadata" = metadata, "covariates" = clinical))
}

ReadCounts_Cain <- function(files, metadata) {
  counts <- ReadMtx(mtx = files$counts$path,
                    cells = files$metadata$path,
                    features = files$genes$path,
                    feature.column = 1,
                    skip.cell = 1,
                    skip.feature = 1)

  # The column names and genes don't get read in correctly by ReadMtx because
  # the input csvs aren't formatted as expected for MTX
  colnames(counts) <- str_replace(colnames(counts), ",.*", "")
  rownames(counts) <- str_replace(rownames(counts), ".*,", "")

  return(counts)
}


##### Lau, et al., 2020 #####
# https://doi.org/10.1073/pnas.2008762117

DownloadData_Lau <- function(metadata_only = FALSE) {
  gse <- getGEO("GSE157827", destdir = dir_lau_raw)

  geo_metadata <- pData(phenoData(gse[[1]]))
  file_geo_metadata <- file.path(dir_lau_raw, "geo_metadata.csv")
  write.csv(geo_metadata, file_geo_metadata)

  if (!metadata_only) {
    # For some reason this function call is failing
    #geo <- getGEOSuppFiles(GEO = "GSE157827", makeDirectory = FALSE,
    #                       baseDir = dir_lau_raw)
    #untar(rownames(geo)[1], exdir = dir_lau_raw)

    url_geo_tar <- "https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE157827&format=file"
    destfile_tar <- file.path(dir_lau_raw, "GSE157827.tar")
    download.file(url_geo_tar, destfile_tar)

    untar(file.path(dir_lau_raw, "GSE157827.tar"), exdir = dir_lau_raw)
  }

  synIDs <- list("clinical_metadata" = list(id = "syn52308080", version = 1))

  files <- DownloadFromSynapse(synIDs, dir_lau_raw)

  files[["geo_metadata"]] = file_geo_metadata
  return(files)
}

ReadMetadata_Lau <- function(files) {
  # We have to get the barcodes from individual files
  geo_metadata <- read.csv(files$geo_metadata, row.names = 1) %>%
                    select(title, diagnosis.ch1) %>%
                    dplyr::rename(sample = title, diagnosis = diagnosis.ch1)

  barcode_files <- list.files(path = dir_lau_raw, pattern = "barcodes",
                              full.names = TRUE)
  barcodes <- lapply(barcode_files, function(filename) {
    bc <- read.table(gzfile(filename)) %>% dplyr::rename(barcode = V1)
    file_info <- str_split(filename, pattern = "/", simplify = TRUE)
    file_info <- str_split(file_info[,length(file_info)], pattern = "_",
                           simplify = TRUE)
    bc$sample <- file_info[,2]
    bc$barcode <- paste(bc$barcode, bc$sample, sep = "_")
    return(bc)
  })

  metadata <- do.call(rbind, barcodes) %>%
                merge(geo_metadata, by = "sample") %>%
                select(barcode, sample, diagnosis)

  # This data set doesn't come with pre-labeled cells
  metadata$broad_class <- NA
  metadata$sub_class <- NA

  clinical <- ReadCovariates_Lau(files)

  return(list("metadata" = metadata, "covariates" = clinical))
}

ReadCovariates_Lau <- function(files) {
  clinical <- read_excel(files$clinical_metadata$path, sheet = "Patient_info")
  clinical <- as.data.frame(clinical) %>% dplyr::rename(sample = ID)
  return(clinical)
}

ReadCounts_Lau <- function(files, metadata) {
  geo_metadata <- read.csv(files$geo_metadata, row.names = 1)
  samples <- rownames(geo_metadata)
  counts_list <- list()

  for (sample in samples) {
    files <- list.files(path = dir_lau_raw,
                        pattern = paste0(sample, "_.*\\.gz"), full.names = TRUE)
    matrix_file <- grep("matrix", files, value = TRUE)
    barcodes_file <- grep("barcodes", files, value = TRUE)
    features_file <- grep("features", files, value = TRUE)

    counts <- ReadMtx(mtx = matrix_file, cells = barcodes_file, features = features_file)
    colnames(counts) <- paste(colnames(counts), geo_metadata[sample, "title"], sep = "_")

    counts_list[[sample]] <- counts
  }

  # Make sure all counts are in the same gene order
  genes <- unique(unlist(lapply(counts_list, rownames)))
  counts_list <- lapply(counts_list, function(X) {
    X[genes,]
  })

  counts <- do.call(cbind, counts_list)

  # Filter as in the paper
  n_genes <- colSums(counts > 0)
  n_umi <- colSums(counts)

  mt_genes <- grepl("^MT-", rownames(counts))
  pct_mt <- colSums(counts[mt_genes,]) / n_umi

  # For some reason this gives 10 more cells than stated in the paper
  # (169,506 instead of 169,496).They don't specify which mitochondrial genes
  # they use, so if they used something other than "^MT-", that may account for
  # the difference.
  cells_keep <- (n_genes > 200) & (n_umi < 20000) & (pct_mt < 0.2)

  return(counts[,cells_keep])
}


##### Leng, et al., 2021 #####
# https://doi.org/10.1038/s41593-020-00764-7

# metadata_only is an unused variable for this dataset as the metadata is
# embedded in the counts RDS files
DownloadData_Leng <- function(metadata_only = FALSE) {
  synIDs <- list("counts_ec" = list(id = "syn22722817", version = 1),
                 "counts_sfg" = list(id = "syn22722860", version = 1))
  files <- DownloadFromSynapse(synIDs, dir_leng_raw)
  return(files)
}

ReadMetadata_Leng <- function(files) {
  sce_ec <- readRDS(files$counts_ec$path)
  sce_sfg <- readRDS(files$counts_sfg$path)

  metadata <- rbind(colData(sce_ec), colData(sce_sfg))

  braak <- list("0" = "Control",
                "2" = "Early Pathology",
                "6" = "AD")

  metadata$cell_id <- rownames(metadata)
  metadata$diagnosis <- unlist(braak[metadata$BraakStage])
  metadata$sub_cluster <- str_replace(metadata$clusterAssignment, "EC:|SFG:", "")

  metadata <- as.data.frame(metadata)

  covariates <- metadata %>% select(SampleID, PatientID, BrainRegion,
                                    BraakStage, SampleBatch, diagnosis) %>%
                    distinct() %>%
                    dplyr::rename(sample = SampleID)

  metadata <- metadata %>% select(cell_id, SampleID, diagnosis,
                                  clusterCellType, sub_cluster)

  return(list("metadata" = metadata, "covariates" = covariates))
}

ReadCounts_Leng <- function(files) {
  sce_ec <- readRDS(files[["counts_ec"]]$path)
  sce_sfg <- readRDS(files[["counts_sfg"]]$path)

  # Both counts matrices have the same genes in the same order already
  return(cbind(counts(sce_ec), counts(sce_sfg)))
}


##### Mathys, et al., 2019 #####
# http://dx.doi.org/10.1038/s41586-019-1195-2

DownloadData_Mathys <- function(metadata_only = FALSE) {
  synIDs <- list("clinical_metadata" = list(id = "syn3191087", version = 11),
                 "cell_metadata" = list(id = "syn18686372", version = 1),
                 "counts" = list(id = "syn18686381", version = 1),
                 "genes" = list(id = "syn18686382", version = 1))

  if (metadata_only) {
    synIDs <- synIDs[1:2]
  }

  files <- DownloadFromSynapse(synIDs, dir_mathys_raw)
  return(files)
}

ReadMetadata_Mathys <- function(files) {
  clinical <- read.csv(files$clinical_metadata$path)
  cellMeta <- read.table(files$cell_metadata$path, sep = "\t", header = TRUE)
  metadata <- merge(cellMeta, clinical,
                    by = "projid", all.x = TRUE, all.y = FALSE)

  # See https://www.synapse.org/#!Synapse:syn3191090 for this information (cogdx)
  diagnosis.codes <- list("1" = "Control",
                          "2" = "MCI",
                          "3" = "MCI",
                          "4" = "AD",
                          "5" = "AD",
                          "6" = "Other")
  diagnosis.codes <- melt(diagnosis.codes)
  colnames(diagnosis.codes) <- c("diagnosis", "cogdx")

  metadata <- merge(metadata, diagnosis.codes, by = "cogdx")

  covariates <- metadata[, c(colnames(clinical), "diagnosis")] %>%
                    distinct() %>%
                    dplyr::rename(sample = projid)

  # Fix age fields to be numeric
  covariates$age_death[covariates$age_death == "90+"] <- 90
  covariates$age_death <- as.numeric(covariates$age_death)
  covariates$age_at_visit_max[covariates$age_at_visit_max == "90+"] <- 90
  covariates$age_at_visit_max <- as.numeric(covariates$age_at_visit_max)

  metadata <- metadata %>% select(TAG, projid, diagnosis, broad.cell.type, Subcluster)

  return(list("metadata" = metadata, "covariates" = covariates))
}

ReadCounts_Mathys <- function(files) {
  counts <- ReadMtx(mtx = files$counts$path,
                    cells = files$cell_metadata$path,
                    features = files$genes$path,
                    feature.column = 1, skip.cell = 1)
  return(counts)
}


##### Morabito, et al., 2021 #####
# https://doi.org/10.1038/s41588-021-00894-z

# NOTE: This data is currently inaccessible on Synapse, so these functions
# have not been updated to get covariate information and this data set will
# not be used.

DownloadData_Morabito <- function() {
  synIDs <- list("metadata" = "syn22130806",
                 "barcodes" = "syn24978676",
                 "genes" = "syn24978737",
                 "counts" = "syn22130805")

  files <- DownloadFromSynapse(synIDs, dir_morabito_raw)
  return(files)
}

ReadMetadata_Morabito <- function(files) {
  metadata <- read.csv(files[["metadata"]]$path)
  metadata <- metadata[, c("X", "Sample.ID", "Diagnosis", "celltype", "cluster")]

  return(metadata)
}

ReadCounts_Morabito <- function(files) {
  counts <- ReadMtx(mtx = files[["counts"]]$path,
                    cells = files[["barcodes"]]$path,
                    features = files[["genes"]]$path,
                    feature.column = 1)
  return(counts)
}


##### SEA-AD #####
# Reference data set (5 donors): https://portal.brain-map.org/atlases-and-data/rnaseq/human-mtg-10x_sea-ad
# Full data set (84 donors): https://portal.brain-map.org/explore/seattle-alzheimers-disease/seattle-alzheimers-disease-brain-cell-atlas-download?edit&language=en
# Metadata: https://www.synapse.org/#!Synapse:syn28256462

# These files are h5ad (AnnData) files. I read the metadata part in with
# reticulate and the "anndata" package, which handles all the categorical
# renaming from the file.
# However, the easiest way to get the data matrix is to use the HDF5Array
# package instead of reticulate. We can't use the R packages that read in
# AnnData (zellkonverter or anndata) because they clobber something from the
# synapser package that makes it not work right.

# metadata_only is an unused variable for this data set, as we need to download
# the data to access the metadata in the anndata file.
DownloadData_SEARef <- function(metadata_only = FALSE) {
  synIDs <- list("individual_metadata" = list(id = "syn31149116", version = 5))
  files <- DownloadFromSynapse(synIDs, downloadLocation = dir_seaad_raw)

  files[["counts"]] = file_searef_h5

  if (!file.exists(files[["counts"]]) & !metadata_only) { # Don't re-download, this file is large
    download.file(url_searef_h5,
                  destfile = files[["counts"]], method = "curl")
  }

  return(files)
}

# metadata_only is an unused variable for this data set, as we need to download
# the data to access the metadata in the anndata file.
DownloadData_SEAAD <- function(metadata_only = FALSE) {
  synIDs <- list("individual_metadata" = list(id = "syn31149116", version = 5))
  files <- DownloadFromSynapse(synIDs, downloadLocation = dir_seaad_raw)

  files[["counts"]] = file_seaad_h5

  if (!file.exists(files[["counts"]]) & !metadata_only) { # Don't re-download, this file is large
    download.file(url_seaad_h5,
                  destfile = files[["counts"]], method = "curl")
  }

  return(files)
}

ReadMetadata_SEARef <- function(files) {
  donor_metadata <- read.csv(files$individual_metadata$path, row.names = 1)

  ad <- import("anndata")
  adata <- ad$read_h5ad(files$counts, backed = 'r')

  metadata <- adata$obs

  metadata$broad_class <- as.character(metadata$subclass_label)
  metadata$broad_class[metadata$class_label == "Neuronal: GABAergic"] = "GABA"
  metadata$broad_class[metadata$class_label == "Neuronal: Glutamatergic"] = "Glut"

  metadata <- merge(metadata, donor_metadata,
                    by.x = "external_donor_name_label", by.y = "individualID")

  metadata <- metadata[, c("sample_name", "external_donor_name_label",
                           "diagnosis", "broad_class", "subclass_label")]
                           #"cluster_label")]

  covariates <- subset(donor_metadata,
                       individualID %in% metadata$external_donor_name_label) %>%
                    dplyr::rename(sample = individualID)

  covariates$ageDeath <- as.numeric(covariates$ageDeath)

  return(list("metadata" = metadata, "covariates" = covariates))
}

ReadMetadata_SEAAD <- function(files) {
  donor_metadata <- read.csv(files$individual_metadata$path, row.names = 1)

  ad <- import("anndata")
  adata <- ad$read_h5ad(files$counts, backed = 'r')

  metadata <- adata$obs

  metadata$broad_class <- as.character(metadata$Subclass)
  metadata$broad_class[metadata$Class == "Neuronal: GABAergic"] = "GABA"
  metadata$broad_class[metadata$Class == "Neuronal: Glutamatergic"] = "Glut"

  metadata <- merge(metadata, donor_metadata,
                    by.x = "Donor.ID", by.y = "individualID")

  metadata <- metadata[, c("sample_id", "Donor.ID", "diagnosis",
                           "broad_class", "Subclass")]

  covariates <- subset(donor_metadata,
                       individualID %in% metadata$Donor.ID) %>%
                    dplyr::rename(sample = individualID)

  covariates$ageDeath <- as.numeric(covariates$ageDeath)

  return(metadata)
}

ReadCounts_SEARef <- function(files) {
  counts <- H5ADMatrix(files$counts)

  col_names <- as.character(HDF5Array(files$counts,
                                      file.path("obs", "sample_name")))
  dimnames(counts)[[2]] <- col_names
  return(counts)
}

ReadCounts_SEAAD <- function(files) {
  counts <- H5ADMatrix(files$counts)

  col_names <- as.character(HDF5Array(files$counts,
                                      file.path("obs", "sample_id")))
  dimnames(counts)[[2]] <- col_names

  return(counts)
}


##### Mayo #####
# Bulk RNA seq data from the Mayo RNA Seq Study:
# https://adknowledgeportal.synapse.org/Explore/Studies/DetailsPage/StudyDetails?Study=syn5550404
#
# Metadata: https://www.synapse.org/#!Synapse:syn29855549
# Filtered counts: https://www.synapse.org/#!Synapse:syn27024951
# Biomart gene conversion: https://www.synapse.org/#!Synapse:syn27024953

DownloadData_Mayo <- function(metadata_only = FALSE) {
  synIDs <- list("metadata" = list(id = "syn29855549", version = 1),
                 "counts" = list(id = "syn27024951", version = 1))

  if (metadata_only) {
    synIDs <- synIDs[1:2]
  }

  files <- DownloadFromSynapse(synIDs, dir_mayo_raw)
  return(files)
}


##### MSBB #####
# Bulk RNA seq data from the Mount Sinai Brain Bank Study:
# https://adknowledgeportal.synapse.org/Explore/Studies/DetailsPage/StudyDetails?Study=syn3159438
#
# Metadata: https://www.synapse.org/#!Synapse:syn29855570
# Filtered counts: https://www.synapse.org/#!Synapse:syn27068754
# Biomart gene conversion: https://www.synapse.org/#!Synapse:syn27068755

DownloadData_MSBB <- function(metadata_only = FALSE) {
  synIDs <- list("metadata" = list(id = "syn29855570", version = 1),
                 "counts" = list(id = "syn27068754", version = 1))

  if (metadata_only) {
    synIDs <- synIDs[1:2]
  }

  files <- DownloadFromSynapse(synIDs, dir_msbb_raw)
  return(files)
}


##### ROSMAP #####
# Bulk RNA seq data from the ROSMAP study:
# https://adknowledgeportal.synapse.org/Explore/Studies/DetailsPage/StudyDetails?Study=syn3219045
#
# Metadata: https://www.synapse.org/#!Synapse:syn29855598
# Filtered counts: https://www.synapse.org/#!Synapse:syn26967451
# Biomart gene conversion: https://www.synapse.org/#!Synapse:syn26967452

DownloadData_ROSMAP <- function(metadata_only = FALSE) {
  synIDs <- list("metadata" = list(id = "syn29855598", version = 1),
                 "clinical_metadata" = list(id = "syn3191087", version = 11),
                 "counts" = list(id = "syn26967451", version = 1))

  if (metadata_only) {
    synIDs <- synIDs[1:3]
  }

  files <- DownloadFromSynapse(synIDs, dir_rosmap_raw)
  return(files)
}


##### Generic bulk functions #####
# These functions all work on Mayo, MSBB, and ROSMAP since the files all come
# from the harmonization effort

ReadMetadata_BulkData <- function(files) {
  metadata <- read.table(files$metadata$path, header = T)

  covariates <- metadata
  metadata <- metadata[,c("specimenID", "diagnosis", "tissue")]

  # ROSMAP needs an extra step to go from biospecimen -> projid, which is needed
  # for comparison with the IHC data
  if ("clinical_metadata" %in% names(files)) {
    clinical <- read.csv(files$clinical_metadata$path) %>%
                      select(projid, individualID) %>% distinct()

    covariates <- merge(covariates, clinical,
                        by = c("individualID"))
  }

  # Necessary because the column names of the counts matrix get converted this
  # way automatically
  metadata$specimenID <- make.names(metadata$specimenID)
  covariates$specimenID <- make.names(covariates$specimenID)

  return(list("metadata" = metadata, "covariates" = covariates))
}

ReadCounts_BulkData <- function(files) {
  counts <- read.table(files[["counts"]]$path, header = TRUE, row.names = 1)
  return(counts)
}

ReadNormCounts_BulkData <- function(files, assay_name, genes, samples) {
  assay <- read.table(files[[assay_name]]$path, header = TRUE, row.names = 1)

  assay <- assay[genes$ensembl_gene_id, samples]
  rownames(assay) <- genes$hgnc_symbol
  return(assay)
}

# Per-tissue outlier detection via PCA. Unlike the RNAseq harmonization study,
# we do this on a per-tissue basis, because points tend to cluster by tissue
# and, especially in the case of Mayo, tissue clusters can be distinctly
# separated on the PCA plot which skews how large the standard deviation is.
# We did not see much bias toward sequencing batch, diagnosis, or sex in the
# PCA, either with all points together or separated by tissue.
#
# Arguments:
#   metadata = a data.frame of metadata, which must have a field for "tissue"
#   counts = a matrix of counts, with columns corresponding to rows in metadata
#   sd_threshold = how many standard deviations from mean must a sample be to
#                  be considered an outlier
#   do_plot = whether to plot the PCA of counts, colored by outlier status
#
# Returns:
#   a vector containing the sample names of outliers
FindOutliers_BulkData <- function(metadata, counts, sd_threshold = 3,
                                  do_plot = FALSE) {

  outliers <- lapply(unique(metadata$tissue), function(tissue) {
    tissue_samples <- metadata$tissue == tissue
    counts_norm <- log2(calculateCPM(counts[,tissue_samples]) + 1)

    pcs <- prcomp(counts_norm, center = TRUE, scale. = TRUE)
    mean_pc <- colMeans(pcs$rotation[,1:2])
    sd_pc <- colSds(pcs$rotation[,1:2])

    # How many SDs is each point away from the mean along PC1 and PC2
    dists <- cbind(abs(pcs$rotation[,1] - mean_pc[1])/sd_pc[1],
                   abs(pcs$rotation[,2] - mean_pc[2])/sd_pc[2])

    outliers <- dists[,1] > sd_threshold | dists[,2] > sd_threshold

    if (do_plot) {
      df <- data.frame(PC1 = pcs$rotation[,1],
                       PC2 = pcs$rotation[,2],
                       outlier = outliers)
      print(ggplot(df, aes(x = PC1, y = PC2, color = outlier)) + geom_point())
    }

    return(rownames(dists)[outliers])
  })

  return(unlist(outliers))
}
