# Uses the "omnideconv" library to run CibersortX. CibersortX runs in a docker
# container that requires a username and token, which can be requested on the
# CibersortX website here: https://cibersortx.stanford.edu/download.php. This
# code expects environment variables CIBERSORT_EMAIL and CIBERSORT_TOKEN to be
# set prior to running.
#
# Arguments:
#   data = a named list that must contain the following fields:
#     singlecell_filename = the filename (plus full path) of the single cell data
#                           file that was created by Save_SingleCellToCibersort().
#     reference = a matrix (genes x celltypes) of the signature generated by
#                 this pipeline or by CibersortX in Step 07.
#     test = a matrix (genes x samples) of bulk data. Must be a dense matrix.
#
#   params = a single-row data frame or a named vector/list of parameters
#            containing the following variables: algorithm, reference_data_name,
#            test_data_name, granularity, filter_level, n_markers, marker_type,
#            marker_subtype, marker_input_type. This variable is unused except
#            to get added to the results object.
#
# Returns:
#   a list containing entries for the celltype percentage estimates ("estimates"),
#   "params", which is the parameter set used for this run, and "markers", which
#   is the list of genes from the CibersortX signature matrix
CibersortX_InnerLoop <- function(data, params) {
  omnideconv::set_cibersortx_credentials(email = Sys.getenv("CIBERSORT_EMAIL"),
                                         token = Sys.getenv("CIBERSORT_TOKEN"))

  # For CibersortX signatures only, we do not need to filter the signature down
  # or worry about markers so we ignore those settings from 'params'.
  # Non-CibersortX signature matrix needs to be filtered.
  if (params$reference_input_type != "cibersortx") {
    signature <- FilterSignature_FromParams(data$reference, params)

    if (Check_MissingMarkers(signature, params) ||
      Check_TooFewMarkers(signature, params, 3) ||
      Check_NotEnoughNewMarkers(signature, params) ||
      Check_TooManyMarkers(signature, params, high_threshold = 8000)) {
      return(NULL)
    }
  } else {
    signature <- data$reference
  }

  file_label <- paste(params$reference_data_name, params$test_data_name,
                      params$granularity, params$reference_input_type,
                      params$normalization, params$regression_method,
                      sep = "_")

  sc_obj <- NULL
  sig_obj <- signature
  params_orig <- params # Save original state because params might get edited below

  # Input/output goes in its own directory
  out_dir <- file.path(dir_cibersort, paste(params_orig, collapse="_"))
  dir.create(out_dir, recursive = TRUE, showWarnings = FALSE)

  # If batch_correct = TRUE, check if there's already a batch-corrected
  # signature. If so, we can skip having CibersortX calculate it and just use
  # the pre-calculated one.
  if (params$batch_correct) {
    sc_obj <- basename(data$singlecell_filename)

    sig_file <- str_replace(file_label,
                            paste0("_", params$reference_input_type),
                            "")

    adjusted_sig <- list.files(path = dir_cibersort,
                               pattern = paste0(sig_file, ".*sigmatrix_Adjusted.txt"),
                               full.names = TRUE)

    # If an adjusted signature is found, there is no need to re-calculate batch
    # correction, so the adjusted signature is passed in instead of the single
    # cell object.
    if (length(adjusted_sig) > 0) {
      sc_obj <- NULL
      params$batch_correct <- FALSE

      if (length(adjusted_sig) > 1) {
        message("Multiple signature matrices found. Using the first one alphabetically.")
      }

      sig_obj <- read.table(adjusted_sig[1], header = TRUE,
                            sep = "\t", row.names = 1)

      # Use the filtered gene list
      sig_obj <- sig_obj[rownames(signature), ]
      sig_obj <- sig_obj[sort(rownames(sig_obj)), ]
    } else {
      # Otherwise we need to put the single cell data file in the input/output directory
      file.copy(data$singlecell_filename,
                file.path(out_dir, basename(data$singlecell_filename)))
    }
  }

  # Convert cell types to lower case to avoid string sorting issues
  orig_cell_names <- colnames(signature)
  colnames(sig_obj) <- str_to_lower(colnames(signature))

  # Ensure signature is a matrix.
  sig_obj <- as.matrix(sig_obj)

  res_pcts <- omnideconv::deconvolute_cibersortx(
    data$test, sig_obj,
    single_cell_object = sc_obj, # filename or NULL
    cell_type_annotations = colnames(sig_obj), # dummy variable, not used but has to have a non-null value
    rmbatch_S_mode = params$batch_correct,
    verbose = TRUE,
    container = "docker",
    input_dir = out_dir,
    output_dir = out_dir,
    qn = FALSE,
    absolute = FALSE,
    label = file_label
  )

  # Cleanup finished docker container and unneeded files
  system("docker rm $(docker ps -a -q --filter ancestor=cibersortx/fractions --filter status=exited)")
  file.remove(file.path(out_dir, "mixture_file_for_cibersort.txt"))
  file.remove(file.path(out_dir, "signature_matrix.txt"))

  if (file.exists(file.path(out_dir, basename(data$singlecell_filename)))) {
    file.remove(file.path(out_dir, basename(data$singlecell_filename)))
  }
  gc()

  # Undo replacement of "." in the cell type names that was needed for CibersortX.
  # res_pcts may or may not have column names already, depending on whether batch
  # correct is true or false.
  colnames(res_pcts) <- orig_cell_names
  colnames(res_pcts) <- str_replace(colnames(res_pcts), "_", ".")

  res <- list("estimates" = res_pcts,
              "params" = params_orig,
              "markers" = rownames(signature))

  return(res)
}
